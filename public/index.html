<html>
    <head>
	<meta charset="UTF-8" />
        <link rel="stylesheet" href="leaflet.css" />
        <script src="leaflet.js"></script>
        <link rel="stylesheet" href="leaflet-search.min.css" />
        <script src="leaflet-search.min.js"></script>
        <script src="leaflet.latlng-graticule.js"></script>
        <script src="leaflet-smoothmarkerbouncing-bundle.min.js"></script>
        <script src="cities.js"></script>
        <style>
            .my-div-icon {
                width: 50px !important; /* Set the desired width */
                height: 50px !important; /* Set the desired height (equal to width for a perfect circle) */
                border-radius: 50%; /* Makes the element circular */
                background-color: transparent; /* Makes the background fully transparent */
                border: 2px solid #333; /* Optional: Add a border for visibility */
            }
        </style>
        <style>
            /* A little thing to separate the latlng-layer from the mutually exclusive ones 
                currently works since it it the single last layer. Needs another solution
                if we were to add more switchable layers to the layer control
            
            .overlays .leaflet-control-layers-overlays label:last-child {
                height: 0;
                border-top: 1px solid #ddd;
                margin: 10px -10px 20px 0px;
            }
                */
        </style>
        <style>
            .leaflet-control-markers-toggle {
            	background-position: 50% 50%;
            	background-repeat: no-repeat;
            	display: block;
            	}
            .leaflet-control-markers {
            	box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            	background: #fff;
            	border-radius: 5px;
            	}
            .leaflet-control-markers-toggle {
            	background-image: url(images/marker-icon.png);
            	width: 36px;
            	height: 36px;
            	}
            .leaflet-retina .leaflet-control-markers-toggle {
            	background-image: url(images/marker-icon-2x.png);
            	background-size: 26px 26px;
            	}
            .leaflet-touch .leaflet-control-markers-toggle {
            	width: 44px;
            	height: 44px;
            	}
            .leaflet-control-markers .leaflet-control-markers-list,
            .leaflet-control-markers-expanded .leaflet-control-markers-toggle {
            	display: none;
            	}
            .leaflet-control-markers-expanded .leaflet-control-markers-list {
            	display: block;
            	position: relative;
            	}
            .leaflet-control-markers-expanded {
            	padding: 6px 10px 6px 6px;
            	color: #333;
            	background: #fff;
            	}
            .leaflet-control-markers-scrollbar {
            	overflow-y: scroll;
            	overflow-x: hidden;
            	padding-right: 5px;
            	}
            .leaflet-control-markers-selector {
            	margin-top: 2px;
            	position: relative;
            	top: 1px;
            	}
            .leaflet-control-markers label {
            	display: block;
            	font-size: 13px;
            	font-size: 1.08333em;
            	}
            .leaflet-control-markers-separator {
            	height: 0;
            	border-top: 1px solid #ddd;
            	margin: 5px -10px 5px -6px;
            	}
            .leaflet-control-markers-header {
                display: flow-root;
            }
            .leaflet-control-markers-header > div:first-child {
                float: left;
            }
            .leaflet-control-markers-header > div:last-child {
                float: right;
            }
            .leaflet-control-markers-addicon {
                font-size: 22px;
                float: right;
                cursor: pointer;
            }
            .leaflet-control-markers-add-dialog {
                display: none;
            }
            .leaflet-control-markers-add-dialog-info {
                color: red;
                font-size: smaller;
            }
            .deletemarker,
            .leaflet-control-markers-store,
            .leaflet-popup-content a {
                cursor: pointer;
            }
            .leaflet-control-markers-store:active
             {
                cursor: progress;
                filter: invert();
            }
            .cursor-add-shortcut{
                cursor: alias;
            }
        </style>
    </head>
    <body>
        <div id='map' style="height: 100vh; width: 100%; margin-top:5px; float: left;"></div>

        <script>
	        function getStyleSheetByFileName(fileName) {
	          // Iterate through all stylesheets in the document
	          for (const sheet of document.styleSheets) {
	            // Check if the current stylesheet's title matches the provided name
	            if (sheet.href && sheet.href.endsWith(fileName)) {
	              return sheet; // Return the matching CSSStyleSheet object
	            }
	          }
	          return null; // Return null if no stylesheet with the given name is found
	        }
            // A fix for leaflet-search finding the correct icons
            let stylesheet=getStyleSheetByFileName("leaflet-search.min.css");
	        for (let i = 0; i < stylesheet.cssRules.length; i++) { 
	            if (stylesheet.cssRules[i].style.background && stylesheet.cssRules[i].style.background.startsWith('url')){
	                let style=stylesheet.cssRules[i].style;
	                style.background=style.background.replace('../images/','images/');
	            }
	        }

            const officialMap = L.imageOverlay('pirates_official_map.jpg', [L.latLng(30.500, -96.836), L.latLng(13.350, -56.836)]);

            /* 5120x3208 pixels, PxPerLong = 134.1, PxPerLat = 193.33, LeftLong = 96,744W, RightLong = 58,563, TopLat = 30,279N, BotLat = 13,687N */
            const minLat = 30.279;
            const minLng = -96.744;
            const maxLat = 13.687;
            const maxLng = -58.563;
            const maxX=5120
            const maxY=3208
            const distLat=maxLat-minLat
            const distLng=maxLng-minLng
            const pxPerLat=maxY/distLat
            const pxPerLng=maxX/distLng

            L.CRS.PiratesCRS = L.extend({}, L.CRS.Simple, {
                transformation: new L.Transformation(0.1*pxPerLng, 0, 0.1*pxPerLat, 0) // Example: scaling and y-axis inversion
            });

            const mapBounds=[L.latLng(minLat, minLng), L.latLng(maxLat, maxLng)];

            const compiledMap = L.imageOverlay('map/PiratesMapFull.png', mapBounds);
            const baseMap = L.imageOverlay('map/PiratesMapBase.png', mapBounds);

            const fullOverlay = L.imageOverlay('map/PiratesMapOverlayFull.png', mapBounds);
            const overlay1560 = L.imageOverlay('map/PiratesMapOverlay1560.png', mapBounds);
            const overlay1600 = L.imageOverlay('map/PiratesMapOverlay1600.png', mapBounds);
            const overlay1620 = L.imageOverlay('map/PiratesMapOverlay1620.png', mapBounds);
            const overlay1640 = L.imageOverlay('map/PiratesMapOverlay1640.png', mapBounds);
            const overlay1660 = L.imageOverlay('map/PiratesMapOverlay1660.png', mapBounds);
            const overlay1680 = L.imageOverlay('map/PiratesMapOverlay1680.png', mapBounds);

            // Generate description popups for each city
            function onEachCityFeature(feature, layer) {
		        let popupContent = `<b>${feature.properties.name} - ${feature.properties.location}</b>`;
                if (feature.properties.link) {
                    popupContent += `<br/>See also: <a href="#" onClick="autopopup=true;searchControl.searchText('${feature.properties.link}');">${feature.properties.link}</a>`;
                }
                popupContent += `<p>${feature.properties.text}</p>`;
                popupContent += `<p>(Eras: ${feature.properties.eras})</p>`;

		        if (feature.properties && feature.properties.popupContent) {
			        popupContent += feature.properties.popupContent;
		        }

		        layer.bindPopup(popupContent);
	        }

            // TODO: Separate by time period, so only relevant cities are clickable?
            var citiesLayer = L.layerGroup();
            L.geoJSON(cities, {
                onEachFeature: onEachCityFeature,
                pointToLayer(feature, latlng) {
			        return L.circle(latlng, { // an invisible, but clickable element for each city
			        	radius: 0.08,
			        	fillColor: '#ffffff',
			        	color: '#000',
			        	weight: 1,
			        	opacity: 0.01,
			        	fillOpacity: 0.01
			        });
		        }
            }).addTo(citiesLayer);

            function reorderCities(era){
                // For a given era, reorders linked cities, so the current city is on top and clickable
                let c={};
                citiesLayer.getLayers()[0].eachLayer(e=>{
                    c[e.getProps().name]=e;
                });
                cities.features.filter(e=>{return e.properties.link})
                .filter(e=>{return e.properties.eras.includes(era)})
                .forEach(e=>{
                    let current=e.properties.name;
                    let other=e.properties.link;
                    let currentEl=c[current].getElement();
                    let otherEl=c[other].getElement()
                    currentEl.before(otherEl)
                })
            }

            var latlngLayer = L.latlngGraticule({
                showLabel: true,
                dashArray: [1, 1],
                zoomInterval: {
                    latitude: [
                        {start: 1, end: 10, interval: 1}
                    ],
                    longitude: [     
                        {start: 1, end: 10, interval: 2}
                    ]
                }
            });

            var baseMaps = {
                "Official Map": officialMap,
                "Compiled Map (Full, static)": compiledMap,
                "Compile Map (dynamic)": baseMap
            };

            var mutuallyExclusiveOverlays = {
              "All cities (all time periods)": fullOverlay,
              "1560 - The Silver Empire": overlay1560, 
              "1600 - Merchants and Smugglers": overlay1600, 
              "1620 - The New Colonists": overlay1620, 
              "1640 - War for Profit": overlay1640, 
              "1660 - The Buccaneer Heroes": overlay1660, 
              "1680 - Pirates' Sunset": overlay1680,
            }
            var otherOverlays = {
                //"Info (clickable)": citiesLayer, // guess this can always be active
              "Lat/Long lines": latlngLayer
            };

            var overlayMaps = {
                ...mutuallyExclusiveOverlays,
                //...otherOverlays
            };

            function getKeyByValue(object, value) {
                return Object.keys(object).find(key => object[key] === value);
            }

            var storage = localStorage.getItem("storage");
            if (storage) {storage=JSON.parse(storage)}
            else { storage={ 
                    baseLayer: getKeyByValue(baseMaps,baseMap), 
                    defaultOverlay: getKeyByValue(mutuallyExclusiveOverlays,fullOverlay), 
                    latlngOverlay: true, // latlngdefault,
                    treasure: null, //{latlng:[lat,lon]} treasure._latlng,
                    inca: null, //{latlng:[lat,lon]} inca._latlng,
                    evil: null, //{ description: "", city: null, latlng: null },
                    missionFrom: null, //{ from: null, to: null },
                    missionTo: null, //{ from: null, to: null },
                    fleet: null, //{ city: null, description: "", latlng: null },
                    train: null //{ city: null, description: "", latlng: null }
                }
            }

            const map = L.map('map', {
                crs: L.CRS.PiratesCRS,
                minZoom: 2,
                maxZoom: 6,
                wheelPxPerZoomLevel: 20,
                layers: [
                    baseMaps[storage.baseLayer],
                    //fullOverlay,
                    citiesLayer,
                    //latLngLayer
                ]
            });

            if (map.hasLayer(baseMap)) {
                if (storage.defaultOverlay) {
                    mutuallyExclusiveOverlays[storage.defaultOverlay].addTo(map)
                }
            }
            if (!map.hasLayer(officialMap)) {
                if (storage.latlngOverlay) {
                    latlngLayer.addTo(map)
                }
            }


            // Since we want to disable the overlays when viewing the official map, these track the state to return to
            var latlngdefault=true
            var overlaydefault=fullOverlay
            const overlaySort=function sortFunction(layerA, layerB, nameA, nameB) {
                // Sorting makes the "All" option on top, followed by the ones starting with years, and any other layers at the bottom
                if (nameA.startsWith("All cities")) {return -1} 
                if (nameB.startsWith("All cities")) {return 1} 
                if (nameA < nameB) {
                    return -1;
                } else if (nameA > nameB) {
                    return 1;
                }
                return 0
            }
            var layerControl = L.control.layers(baseMaps,overlayMaps,{
                collapsed: false,
                sortLayers: true,
                sortFunction: overlaySort
            }).addTo(map);
            layerControl._container.classList.add("overlays");
            var otherOverlaysControl = L.control.layers(null,otherOverlays,{collapsed: false}).addTo(map);

            // Some logic to handle switching overlays on and off, and only having one city overlay at a time
            function removeWithTimeout(layer) {
              setTimeout(function() {
                map.removeLayer(layer);
              }, 10);
            }

            var ready=true 
            map.on('overlayadd', function(event)
            {
                if (ready) {
                    if (Object.keys(mutuallyExclusiveOverlays).includes(event.name)) {
                        overlaydefault=event.layer
                        storage.defaultOverlay=getKeyByValue(mutuallyExclusiveOverlays,event.layer);
                        for (o in mutuallyExclusiveOverlays) {
                            if ( event.name != o && map.hasLayer(mutuallyExclusiveOverlays[o]) ) {
                                console.log("remove layer '"+o+"'");
                                removeWithTimeout(mutuallyExclusiveOverlays[o]);
                            }
                        }
                    }
                    let era=event.name.split(" ")[0]
                    if (parseInt(era)){
                        reorderCities(parseInt(era));
                    }
                    storage.latlngOverlay=map.hasLayer(latlngLayer);
                    localStorage.setItem("storage",JSON.stringify(storage));
                }

            });          
            var lastBaseLayer=undefined;
            var lastOverlay=undefined;
            map.on('baselayerchange', function(event) {
                // if lastBaseLayer is unset, this is the first loading...
                if ( event.layer == officialMap ) {
                    // if we're switching to official map, we need to make sure latlng is disabled
                    if (lastBaseLayer) {
                        storage.latLngLayer=map.hasLayer(latlngLayer) // store current value
                    }
                    if (map.hasLayer(latlngLayer)) {
                        removeWithTimeout(latlngLayer)
                    }
                    map.removeControl(otherOverlaysControl); //map.removeLayer(latlngLayer);
                }
                if (lastBaseLayer==baseMap) {
                    // switching away from baseMap with possible overlays
                    lastOverlay=undefined;
                    for (o in mutuallyExclusiveOverlays) {
                        if (map.hasLayer(mutuallyExclusiveOverlays[o])) {
                            lastOverlay=mutuallyExclusiveOverlays[o];
                        }
                        removeWithTimeout(mutuallyExclusiveOverlays[o]);
                        layerControl.removeLayer(mutuallyExclusiveOverlays[o]);
                    }
                    storage.defaultOverlay=getKeyByValue(mutuallyExclusiveOverlays,lastOverlay)
                }
                if (event.layer==baseMap && lastBaseLayer) {
                    // switching to baseMap so add overlay options and possibly activate
                    if (lastOverlay) {
                            map.addLayer(lastOverlay);
                    }
                    for (o in mutuallyExclusiveOverlays) {
                        layerControl.addOverlay(mutuallyExclusiveOverlays[o],o);
                    }
                }
                if (lastBaseLayer==officialMap) {
                    // switching away from officialMap means we can enable latlng layer again
                    if(storage.latLngLayer) {
                        map.addLayer(latlngLayer);
                    }
                    otherOverlaysControl.addTo(map);
                }
                lastBaseLayer=event.layer;
                storage.baseLayer=getKeyByValue(baseMaps,lastBaseLayer);
                localStorage.setItem("storage",JSON.stringify(storage));
            });

            // make sure we can write "Leogane" and still find "Léogâne"
            const normalizeSearch = function (text, records) { // copied function from leaflet-search source
                const frecords = {}             
                text = text.replace(new RegExp('[.*+?^${}()|[\]\\]','g'), '')
                // sanitize remove all special characters               
                if (text === '') {
                  return []
                }               
                const init = this.options.initial ? '^' : ''
                const icase = !this.options.casesensitive ? 'i' : undefined             
                const regSearch = new RegExp(init + text, icase)                
                for (const key in records) {
                    // this part makes sure we normalize the key before comparing
                  if (regSearch.test(key.normalize('NFD').replace(/[\u0300-\u036f]/g, ''))) {
                    frecords[key] = records[key]
                  }
                }               
                return frecords;
            }

            var autopopup=false; // if set, the buildtip will assume a direct search from link, and act on it
            var searchControl = new L.Control.Search({
                layer: citiesLayer, // The layer to search within
                propertyName: 'name', // The property containing the label/name to search
                filterData: normalizeSearch,
                marker: false, // Don't create a new marker on search result
                initial: false,
                firstTipSubmit: true,
                moveToLocation: function(latlng, title, map) {
                    map.setView(latlng, 8); // Zoom to the found location
                },
                buildTip: function(text,val) {
                    // This is just so we can hijack the search function as a clickable action in city descriptions
                    if (autopopup) {
                        autopopup=false; // reset the autopopup
                        //map.setView(val.layer._latlng, 8); // unnecessary as long as we're alrady accessing from the "twin" city
                        val.layer.openPopup();
                    }
                    return '<a href="#">'+text+'</a>';
                }
            });

	        searchControl.on('search:locationfound', function(e) {
	            // Access the found location data
	            var latlng = e.latlng;
	            var title = e.title;
	            var layer = e.layer;
            
	            // Perform actions with the found location data
	            //console.log("Location found:", layer.feature.properties.name, latlng);
            
	            if (layer) {
	                layer.openPopup();
	            }
	        });

            function cityLatlng(city) {
                const s=searchControl._recordsFromLayer()[city]
                return [s.lat,s.lng]
            }
	        map.addControl(searchControl);

            /*   MARKERS   */

            /* First enable handling of GeoJSON properties */
            L.Layer.include({
                getProps: function () {
                    var feature = this.feature = this.feature || {}; // Initialize the feature, if missing.
                    feature.type = 'Feature';
                    feature.properties = feature.properties || {}; // Initialize the properties, if missing.
                    return feature.properties;
                },
                setProps: function (props) {
                    for(p in props){
                        this.getProps()[p]=props[p];
                    }
                    return this;
                }
            });

            /* Define some icons */
            const treasureIcon = L.icon({
                iconUrl: 'images/treasure-icon.png',
                iconSize:     [50, 40], // size of the icon
                iconAnchor:   [36, 28], // point of the icon which will correspond to marker's location
                popupAnchor:  [-20, -28] // point from which the popup should open relative to the iconAnchor
            });
            const enemyIcon = L.icon({
                iconUrl: 'images/enemy-icon.png',
                iconSize:     [42, 44], // size of the icon
                iconAnchor:   [13, 42], // point of the icon which will correspond to marker's location
                popupAnchor:  [0, -42] // point from which the popup should open relative to the iconAnchor
            });
            const familyIcon = L.icon({
                iconUrl: 'images/family-icon.png',
                iconSize:     [42, 50], // size of the icon
                iconAnchor:   [21, 25], // point of the icon which will correspond to marker's location
                popupAnchor:  [0, -25] // point from which the popup should open relative to the iconAnchor
            });
            var missionFromIcon = L.icon({
                iconUrl: 'images/missionfrom-icon.png',
                iconSize:     [48, 48], // size of the icon
                iconAnchor:   [24, 24], // point of the icon which will correspond to marker's location
                popupAnchor:  [0, -24] // point from which the popup should open relative to the iconAnchor
            });
            var missionToIcon = L.icon({
                iconUrl: 'images/missionto-icon.png',
                iconSize:     [48, 48], // size of the icon
                iconAnchor:   [24, 24], // point of the icon which will correspond to marker's location
                popupAnchor:  [0, -24] // point from which the popup should open relative to the iconAnchor
            });
            var fleetIcon = L.icon({
                iconUrl: 'images/fleet-icon.png',
                iconSize:     [63, 40], // size of the icon
                iconAnchor:   [30, 38], // point of the icon which will correspond to marker's location
                popupAnchor:  [0, -38] // point from which the popup should open relative to the iconAnchor
            });
            var trainIcon = L.icon({
                iconUrl: 'images/train-icon.png',
                iconSize:     [32, 68], // size of the icon
                iconAnchor:   [16, 65], // point of the icon which will correspond to marker's location
                popupAnchor:  [0, -50] // point from which the popup should open relative to the iconAnchor
            });

            const storeMarkers=function() {
                let json=JSON.stringify(markerGroup.toGeoJSON());
                localStoreage.setItem("markers",json)
            }
            var storedMarkers=localStorage.getItem("markers");

            // Generate description popups for each marker
            function onEachMarkerFeature(feature, layer) {
                let popupContent="";
                switch (feature.properties.type) {
                    case "treasure":
                        popupContent = `<b>Pirate Treasure</b>`;
                        break;
                    case "inca":
                        popupContent = `<b>Inca Treasure</b>`;
                        break;
                    case "family":
                        popupContent = `<b>Long lost ${feature.properties.description}</b>`;
                        break;
                    case "evil":
                        popupContent = `<b>${feature.properties.description}</b>`;
                        break;
                    case "fleet":
                        popupContent = `<b>Treasure fleet</b>`;
                        if (feature.properties.description) {
                            popupContent+=`<p>${feature.properties.description}</p>`
                        }
                        break;
                    case "train":
                        popupContent = `<b>Silver train</b>`;
                        if (feature.properties.description) {
                            popupContent+=`<p>${feature.properties.description}</p>`
                        }
                        break;
                    case "missionsource":
                        popupContent = `<b>Mission start</b><p><a onClick="javascript:flyToMissionTarget(this);">Show target</a></p>`;
                        break;
                    case "missiontarget":
                        popupContent = `<b>Mission target</b><p><a onClick="javascript:flyToMissionSource(this);">Show start</a></p>`;
                        break;
                    default:
                        if (feature.properties.description) {
                            popupContent=`<b>${feature.properties.description}</b>`
                        }
                }
                popupContent+=`<p><a class="deletemarker">Delete this marker</a></p>`;
                let popup=L.popup({content: popupContent});
                popup.marker=layer;
		        layer.bindPopup(popup);
	        }
            const flyToMissionTarget=function(e){
                console.log(e);
                map.flyTo(markerGroup.getLayers().filter(l=>{return l.getProps().type=="missiontarget"})[0].getLatLng())
            }
            const flyToMissionSource=function(e){
                console.log(e);
                map.flyTo(markerGroup.getLayers().filter(l=>{return l.getProps().type=="missionsource"})[0].getLatLng())
            }
            var markerGroup = L.geoJSON(null, {
                onEachFeature: onEachMarkerFeature,
                pointToLayer(feature, latlng) {
                    switch (feature.properties.type) {
                        case "treasure":
                        case "inca":
                            return L.marker(latlng,{icon: treasureIcon,draggable:true});
                            break;
                        case "family":
                            return L.marker(latlng,{icon: familyIcon,draggable:true});
                            break;
                        case "evil":
                            return L.marker(latlng,{icon: enemyIcon});
                            break;
                        case "fleet":
                            return L.marker(latlng,{icon: fleetIcon});
                            break;
                        case "train":
                            return L.marker(latlng,{icon: trainIcon});
                            break;
                        case "missionsource":
                            return L.marker(latlng,{icon: missionFromIcon});
                            break;
                        case "missiontarget":
                            return L.marker(latlng,{icon: missionToIcon});
                            break;
                        default:
                            return L.marker(latlng);
                    }
		        }
            });
        
            if(storedMarkers) { markerGroup.addData(JSON.parse(storedMarkers)).addTo(map); }

            const addMarker=function(latlng,props) {
                markerGroup.addData(L.marker(latlng).setProps(props).toGeoJSON())
            }
            markerGroup.on("popupopen",function(e){
                let deleteLink=e.popup._container.getElementsByClassName("deletemarker")[0]
                deleteLink.onclick=function(){
                    markerGroup.removeLayer(this)
                }.bind(e.popup.marker)
            });

            L.Control.Markers = L.Control.extend({
                options: {
        		// @option collapsed: Boolean = true
        		// If `true`, the control will be collapsed into an icon and expanded on mouse hover, touch, or keyboard activation.
        		collapsed: true,
	        	position: 'topright'
                },
                initialize: function (markerGroup, options) {
		            L.Util.setOptions(this, options);

		            this._markerControlInputs = [];
                    this._markerGroup=markerGroup;
		            this._markers = [];
		            this._handlingClick = false;
		            this._preventClick = false;

		            for (var i in markerGroup._layers) {
			            this._addMarker(markerGroup._layers[i]);
		            }
	            },

                onAdd: function (map) {
            		this._initLayout();
            		this._update();

            		this._map = map;
                    this._markerGroup.on("layeradd layerremove",this._onMarkerGroupChange, this);
             		return this._container;
	            },
                addTo: function (map) {
		            L.Control.prototype.addTo.call(this, map);
		            // Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
		            return this._expandIfNotCollapsed();
	            },
                onRemove: function () {
                    this._markerGroup.off("layeradd layerremove",this._onMarkerGroupChange, this);
            	},

            	// @method addOverlay(layer: Layer, name: String): this
            	// Adds an overlay (checkbox entry) with the given name to the control.
            	addMarker: function (id,name) {
            		this._addMarker(id,name);
            		return (this._map) ? this._update() : this;
            	},

            	// @method removeLayer(layer: Layer): this
            	// Remove the given layer from the control.
            	removeMarker: function (marker) {
            		marker.off('add remove', this._onMarkerChange, this);
                
            		var obj = this._getMarker(L.Util.stamp(marker));
            		if (obj) {
            			this._markers.splice(this._markers.indexOf(obj), 1);
            		}
            		return (this._map) ? this._update() : this;
            	},
               
                expand: function () {
            		L.DomUtil.addClass(this._container, 'leaflet-control-markers-expanded');
            		this._section.style.height = null;
            		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
            		if (acceptableHeight < this._section.clientHeight) {
            			L.DomUtil.addClass(this._section, 'leaflet-control-markers-scrollbar');
            			this._section.style.height = acceptableHeight + 'px';
            		} else {
            			L.DomUtil.removeClass(this._section, 'leaflet-control-markers-scrollbar');
            		}
            		//this._checkDisabledLayers();
            		return this;
            	},

            	// @method collapse(): this
            	// Collapse the control container if expanded.
            	collapse: function () {
            		L.DomUtil.removeClass(this._container, 'leaflet-control-markers-expanded');
            		return this;
            	},

                storeMarkers: function() {
                    let json=JSON.stringify(this._markerGroup.toGeoJSON());
                    localStorage.setItem("markers",json)
                },

                _initLayout: function () {
            		var className = 'leaflet-control-markers',
            		    container = this._container = L.DomUtil.create('div', className),
            		    collapsed = this.options.collapsed;

            		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
            		container.setAttribute('aria-haspopup', true);

            		L.DomEvent.disableClickPropagation(container);
            		L.DomEvent.disableScrollPropagation(container);

            		var section = this._section = L.DomUtil.create('section', className + '-list');

            		if (collapsed) {
            			this._map.on('click', this.collapse, this);
                    
            			L.DomEvent.on(container, {
            				mouseenter: this._expandSafely,
            				mouseleave: this.collapse
            			}, this);
            		}
                
            		var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
            		link.href = '#';
            		link.title = 'Markers';
            		link.setAttribute('role', 'button');
                
            		L.DomEvent.on(link, {
            			keydown: function (e) {
            				if (e.keyCode === 13) {
            					this._expandSafely();
            				}
            			},
            			// Certain screen readers intercept the key event and instead send a click event
            			click: function (e) {
            				L.DomEvent.preventDefault(e);
            				this._expandSafely();
            			}
            		}, this);
                
            		if (!collapsed) {
            			this.expand();
            		}
                    var header=L.DomUtil.create('div', className+"-header",section);
                    var title=L.DomUtil.create('div',null,header);
                    var b=L.DomUtil.create('b',null,title);
                    b.innerText="Markers";

                    var add=L.DomUtil.create('div',null,header);
                    var addIcon=L.DomUtil.create('span', className+"-addicon",add);
                    addIcon.innerText='+';
                    this._addDialog=L.DomUtil.create('div',className+"-add-dialog",add);
                    var form=L.DomUtil.create('form',null,this._addDialog);
                    var select=L.DomUtil.create('select',null,form);
                    ["treasure","inca","evil","family","fleet","train","missionsource","missiontarget","informant"].forEach(type=>{
                        let option=L.DomUtil.create('option',null,select);
                        option.innerText=type;
                    });
                    var br=L.DomUtil.create('br',null,form);
                    var input=L.DomUtil.create('input',null,form);
                    input.type="text";
                    br=L.DomUtil.create('br',null,form);
                    var info=L.DomUtil.create('span',className+"-add-dialog-info",form);
                    info.innerHTML="Click on map to create new marker<br/>(existing marker of same type will be removed)";

                    this._addIconOnClick=function(){
                        var addDialog=this._addDialog;
                        var addIcon=addDialog.parentNode.getElementsByClassName("leaflet-control-markers-addicon")[0];
                        if (addIcon.innerText=="+") {
                            addDialog.style.display="unset";   
                            addIcon.innerText="x";
                            map.on("click",this._addOnMapClick,this);
                            map.getPane("overlayPane").classList.add("cursor-add-shortcut");
                        } else {
                            map.off("click",this._addOnMapClick,this);
                            map.getPane("overlayPane").classList.remove("cursor-add-shortcut");
                            addDialog.style.display=null;
                            addIcon.innerText="+";
                        }
                    }.bind(this)
                    this._addOnMapClick=function(e){
                        var addDialog=this._addDialog;
                        var addIcon=addDialog.parentNode.getElementsByClassName("leaflet-control-markers-addicon")[0];
                        if (addIcon.innerText=="+") {
                            map.off("click",this._addOnMapClick,this);
                            map.getPane("overlayPane").classList.remove("cursor-add-shortcut");
                            return false;
                        }
                        var coord = e.latlng;
                        var lat = coord.lat;
                        var lng = coord.lng;
                        var form=addDialog.getElementsByTagName("form")[0];
                        var input=form.getElementsByTagName("select")[0];
                        var type=input.value;
                        if (type != "informant") {
                            oldMarker=this._markerGroup.getLayers().filter(l=>{return l.getProps().type==type})[0];
                            if (oldMarker) {
                                this._markerGroup.removeLayer(oldMarker);
                            }

                        }
                        var o = {
                            "type": "Feature",
                            "properties": {
                                "type": type,
                                },
                            "geometry": {
                                "type": "Point",
                                "coordinates": [coord.lng, coord.lat] // [longitude, latitude]
                            }
                        };
                        switch (type) {
                            case "train":
                            case "fleet":
                            case "family":
                            case "evil":
                                input=form.getElementsByTagName("input")[0];
                                o.properties["description"] = input.value;
                        }
                        markerGroup.addData(o);

                        this._addIconOnClick.call(this); // let the original function clean up
                    }
                    addIcon.onclick=this._addIconOnClick.bind(this);
                    //header.appendChild(title);
                    
            		this._markersList = L.DomUtil.create('div', className + '-markers', section);

                    var separator=L.DomUtil.create('div', className + '-separator', section);
                    var div=L.DomUtil.create('div', null, section);
                    var a=L.DomUtil.create('a', className + "-store", div);
                    a.innerText="Store in persistant storage";
                    a.onclick=this.storeMarkers.bind(this);
            		container.appendChild(section);
            	},
                _getMarker: function (id) {
                    return this._markerGroup.getLayer(id);
            	},
                _addMarker: function (marker) {
            		if (this._map) {
            			marker.on('add remove', this._onMarkerChange, this);
            		}
                
            		this._markers.push({
            			marker: marker,
            			id: L.Util.stamp(marker),
                        type: marker.getProps().type
            		});

                    /*
            		if (this.options.sortLayers) {
            			this._layers.sort(Util.bind(function (a, b) {
            				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
            			}, this));
            		}
                
            		if (this.options.autoZIndex && layer.setZIndex) {
            			this._lastZIndex++;
            			layer.setZIndex(this._lastZIndex);
            		}
                    */
            		this._expandIfNotCollapsed();
            	},
                _update: function () {
            		if (!this._container) { return this; }

            		L.DomUtil.empty(this._markersList);

            		this._markerControlInputs = [];
            		var i, obj;

                    for (l in this._markerGroup._layers){
            		//for (i = 0; i < this._markersgroup._layers].length; i++) {
            			obj = this._markerGroup._layers[l];
            			this._addItem(obj);
            		}                
            		return this;
            	},
                _onMarkerChange: function (e) {
            		if (!this._handlingClick) {
            			this._update();
            		}
                
            		var obj = this._getMarker(L.Util.stamp(e.target));
                
            		// @namespace Map
            		// @section Layer events
            		// @event baselayerchange: LayersControlEvent
            		// Fired when the base layer is changed through the [layers control](#control-layers).
            		// @event overlayadd: LayersControlEvent
            		// Fired when an overlay is selected through the [layers control](#control-layers).
            		// @event overlayremove: LayersControlEvent
            		// Fired when an overlay is deselected through the [layers control](#control-layers).
            		// @namespace Control.Layers
            		var type = e.type === 'add' ? 'markeradd' : 'markerremove';
                
            		if (type) {
            			this._map.fire(type, obj);
            		}
            	},
                _onMarkerGroupChange: function (e) {
            		if (!this._handlingClick) {
            			this._update();
            		}
                
            		var obj = this._getMarker(L.Util.stamp(e.target));
                    var marker=e.layer;
                
            		// @namespace Map
            		// @section Layer events
            		// @event baselayerchange: LayersControlEvent
            		// Fired when the base layer is changed through the [layers control](#control-layers).
            		// @event overlayadd: LayersControlEvent
            		// Fired when an overlay is selected through the [layers control](#control-layers).
            		// @event overlayremove: LayersControlEvent
            		// Fired when an overlay is deselected through the [layers control](#control-layers).
            		// @namespace Control.Layers
            		var type = e.type === 'add' ? 'markeradd' : 'markerremove';
                
            		if (type) {
            			this._map.fire(type, obj);
            		}
            	},

            	_addItem: function (obj) {
            		var label = document.createElement('label'),
            		    checked = this._map.hasLayer(obj),
                        id=obj._leaflet_id,
                        type=obj.getProps().type,
            		    input;

                    input = document.createElement('input');
            		input.type = 'checkbox';
            		input.className = 'leaflet-control-markers-selector';
            		input.defaultChecked = checked;
                    label.dataset.markerid=id
            
            		this._markerControlInputs.push(input);
            		input.markerId = id;
                    input.dataset.markerid=id
                
            		L.DomEvent.on(input, 'click', this._onInputClick, this);
                
            		var name = document.createElement('span');
            		name.innerHTML = ' ' + type;
                    name.dataset.markerid=id
                    name.onclick=function(e){
                        let s=e.target;
                        let id=s.dataset.markerid;
                        let marker=markerGroup.getLayer(id);
                        if (map.hasLayer(marker)){
                            console.log(marker);
                            map.flyTo(marker._latlng);
                            L.Marker.stopAllBouncingMarkers(true);
                            marker.bounce(1);
                            marker.openPopup();
                        }
/*
                        switch (marker) {
                            case missionFrom:
                                console.log(storage.missionFrom);
                                break;
                            case missionTo:
                                console.log(storage.missionTo);
                                break;
                        }
*/
                        return false; // label-click won't change checkbox
                    }


            		// Helps from preventing layer control flicker when checkboxes are disabled
            		// https://github.com/Leaflet/Leaflet/issues/2771
            		var holder = document.createElement('span');
                
            		label.appendChild(holder);
            		holder.appendChild(input);
            		holder.appendChild(name);
                
            		var container = this._markersList;
            		container.appendChild(label);
                
            		//this._checkDisabledMarkers();
            		return label;
            	},
                _onInputClick: function () {
            		// expanding the control on mobile with a click can cause adding a marker - we don't want this
            		if (this._preventClick) {
            			return;
            		}
                
            		var inputs = this._markerControlInputs,
            		    input, marker,id;
            		var addedMarkers = [],
            		    removedMarkers = [];
                
            		this._handlingClick = true;
                
                    addedMarkers=inputs.filter(i=>{return i.checked==true}).map(i=>{return i.dataset.markerid});
                    removedMarkers=inputs.filter(i=>{return i.checked==false}).map(i=>{return i.dataset.markerid});

                    removedMarkers.forEach(id=>{
                                            let marker=this._markerGroup._layers[id];
                                            if (this._map.hasLayer(marker)) {
                                                this._map.removeLayer(marker);
                                            }
                                        });
                    addedMarkers.forEach(id=>{
                                            let marker=this._markerGroup._layers[id];
                                            if (!this._map.hasLayer(marker)) {
                                                this._map.addLayer(marker);
                                            }
                                        });
            		this._handlingClick = false;
                
            		this._refocusOnMap();
            	},
                _expandIfNotCollapsed: function () {
            		if (this._map && !this.options.collapsed) {
            			this.expand();
            		}
            		return this;
            	},

            	_expandSafely: function () {
            		var section = this._section;
            		this._preventClick = true;
            		L.DomEvent.on(section, 'click', L.DomEvent.preventDefault);
            		this.expand();
            		var that = this;
            		setTimeout(function () {
            			L.DomEvent.off(section, 'click', L.DomEvent.preventDefault);
            			that._preventClick = false;
            		});
            	}
            });            
            L.control.markers=function(markerGroup, opts) {
                return new L.Control.Markers(markerGroup, opts);
            }

            var markerControl;
            setTimeout(function() { // give the main map some time to finish initializing
                markerControl=L.control.markers(markerGroup,{collapsed: false, position: "topright"}).addTo(map);
              }, 10);

            /*  
            map.on('click', function(e){
              var coord = e.latlng;
              var lat = coord.lat;
              var lng = coord.lng;
              console.log("You clicked the map at L.latLng(" + lat + ", " + lng + "), GeoJSON coordinates ["+lng+", "+lat +"]");
            });
            */
            map.setView(L.latLng(24, -78), 3);
            document.getElementById('map').style.cursor = 'crosshair';
      
        </script>
    </body>
</html>
